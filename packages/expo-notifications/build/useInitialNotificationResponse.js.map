{"version":3,"file":"useInitialNotificationResponse.js","sourceRoot":"","sources":["../src/useInitialNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAC5C,OAAO,EAAE,QAAQ,EAAE,MAAM,cAAc,CAAC;AAGxC,OAAO,EAAE,2BAA2B,EAAE,MAAM,yCAAyC,CAAC;AAEtF,yDAAyD;AACzD,8DAA8D;AAC9D,sDAAsD;AACtD,wDAAwD;AACxD,EAAE;AACF,mDAAmD;AACnD,4DAA4D;AAC5D,iEAAiE;AACjE,2CAA2C;AAE3C,uCAAuC;AACvC,qBAAqB;AACrB,uFAAuF;AACvF,wEAAwE;AACxE,kEAAkE;AAClE,IAAI,iCAAiC,GAA4C,SAAS,CAAC;AAE3F,SAAS,kCAAkC;IACzC,8CAA8C;IAC9C,UAAU,CAAC,GAAG,EAAE;QACd,iDAAiD;QACjD,+CAA+C;QAC/C,2BAA2B;QAC3B,iCAAiC,GAAG,2BAA2B,EAAE,IAAI,IAAI,CAAC;QAC1E,iDAAiD;QACjD,QAAQ,CAAC,mBAAmB,CAAC,QAAQ,EAAE,kCAAkC,CAAC,CAAC;IAC7E,CAAC,EAAE,CAAC,CAAC,CAAC;AACR,CAAC;AAED,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,EAAE,kCAAkC,CAAC,CAAC;AAExE;;;;;;GAMG;AACH,MAAM,CAAC,OAAO,UAAU,8BAA8B;IACpD,MAAM,CAAC,2BAA2B,EAAE,8BAA8B,CAAC,GAAG,QAAQ,CAE5E,iCAAiC,CAAC,CAAC;IAErC,SAAS,CAAC,GAAG,EAAE;QACb,gDAAgD;QAChD,qEAAqE;QACrE,MAAM,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE;YAChC,qDAAqD;YACrD,sEAAsE;YACtE,8BAA8B,CAC5B,eAAe,CAAC,EAAE,CAAC,eAAe,IAAI,iCAAiC,IAAI,IAAI,CAChF,CAAC;QACJ,CAAC,EAAE,CAAC,CAAC,CAAC;QAEN,OAAO,GAAG,EAAE;YACV,YAAY,CAAC,SAAS,CAAC,CAAC;QAC1B,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,2BAA2B,CAAC;AACrC,CAAC","sourcesContent":["import { useEffect, useState } from 'react';\nimport { AppState } from 'react-native';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { getLastNotificationResponse } from './SharedNotificationResponseListener.fx';\n\n// We know that the initial notification response happens\n// between registering the listener in global scope of the app\n// and execution of setTimeout(0)-d callback scheduled\n// inside a \"change to active\" app state event listener.\n//\n// An approach that is simple enough and works well\n// is to set the global value once we know that if there was\n// an \"initial notification response\" it has already been emitted\n// and is the \"last notification response\".\n\n// Initial notification response holder\n// The value changes:\n//   `undefined` -> `NotificationResponse` if there is an initial notification response\n//   `undefined` -> `null` if there was no initial notification response\n// Both changes happen in the `dispatchSetInitialResponseAndClear`\nlet globalInitialNotificationResponse: NotificationResponse | undefined | null = undefined;\n\nfunction dispatchSetInitialResponseAndClear() {\n  // process.nextTick/requestAnimationFrame-like\n  setTimeout(() => {\n    // If there was an initial notification response,\n    // fetch it from the shared listener, otherwise\n    // let's define it as null.\n    globalInitialNotificationResponse = getLastNotificationResponse() ?? null;\n    // We don't need to ever run this function again.\n    AppState.removeEventListener('change', dispatchSetInitialResponseAndClear);\n  }, 0);\n}\n\nAppState.addEventListener('change', dispatchSetInitialResponseAndClear);\n\n/**\n * Returns an initial notification response if the app\n * was opened as a result of tapping on a notification,\n * null if the app doesn't seem to be opened as a result\n * of tapping on a notification, or undefined until we are sure\n * of which to return.\n */\nexport default function useInitialNotificationResponse() {\n  const [initialNotificationResponse, setInitialNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(globalInitialNotificationResponse);\n\n  useEffect(() => {\n    // process.nextTick & requestAnimationFrame-like\n    // Executes after dispatchSetInitialResponseAndClear's inner callback\n    const timeoutId = setTimeout(() => {\n      // Ensure the value is not undefined (if by this time\n      // it's still undefined there was no \"initial notification response\").\n      setInitialNotificationResponse(\n        currentResponse => currentResponse ?? globalInitialNotificationResponse ?? null\n      );\n    }, 0);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, []);\n\n  return initialNotificationResponse;\n}\n"]}